"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const events_1 = require("events");
const net_1 = require("net");
const ssh2_1 = require("ssh2");
function getConnectConfig(config) {
    const { 
    // Doing it the other way around would be too much
    /* eslint-disable @typescript-eslint/no-unused-vars */
    srcAddr, srcPort, dstAddr, dstPort, localAddr, localPort, 
    /* eslint-enable @typescript-eslint/no-unused-vars */
    ...connectConfig } = config;
    return connectConfig;
}
function getSshTunnelConfig(config) {
    const connectConfig = { port: 22, ...getConnectConfig(config) };
    return Object.assign({}, {
        srcPort: 0,
        srcAddr: '127.0.0.1',
        dstAddr: '127.0.0.1',
        dstPort: connectConfig.port,
    }, {
        localAddr: '127.0.0.1',
        localPort: 0,
    }, config);
}
class SshTunnel extends events_1.EventEmitter {
    constructor(config = {}) {
        super();
        this.connections = new Set();
        this.rawConfig = getSshTunnelConfig(config);
        this.sshClient = new ssh2_1.Client();
        this.forwardOut = util_1.promisify(this.sshClient.forwardOut.bind(this.sshClient));
        this.server = net_1.createServer(async (socket) => {
            this.connections.add(socket);
            socket.on('error', (err) => {
                var _a;
                err.origin = (_a = err.origin) !== null && _a !== void 0 ? _a : 'connection';
                this.server.emit('error', err);
            });
            socket.once('close', () => {
                this.connections.delete(socket);
            });
            try {
                const { srcAddr, srcPort, dstAddr, dstPort } = this.rawConfig;
                const channel = await this.forwardOut(srcAddr, srcPort, dstAddr, dstPort);
                socket.pipe(channel).pipe(socket);
            }
            catch (err) {
                err.origin = 'ssh-client';
                socket.destroy(err);
            }
        });
        this.serverListen = util_1.promisify(this.server.listen.bind(this.server));
        this.serverClose = util_1.promisify(this.server.close.bind(this.server));
        ['close', 'connection', 'error', 'listening'].forEach((eventName) => {
            this.server.on(eventName, this.emit.bind(this, eventName));
        });
    }
    get config() {
        const serverAddress = this.server.address();
        return {
            ...this.rawConfig,
            localPort: (typeof serverAddress !== 'string' && (serverAddress === null || serverAddress === void 0 ? void 0 : serverAddress.port)) ||
                this.rawConfig.localPort,
        };
    }
    async listen() {
        const { localPort, localAddr } = this.rawConfig;
        await this.serverListen(localPort, localAddr);
        try {
            await Promise.race([
                events_1.once(this.sshClient, 'error').then(([err]) => {
                    throw err;
                }),
                (() => {
                    const waitForReady = events_1.once(this.sshClient, 'ready');
                    this.sshClient.connect(getConnectConfig(this.rawConfig));
                    return waitForReady;
                })(),
            ]);
        }
        catch (err) {
            await this.serverClose();
            throw err;
        }
    }
    async close() {
        const [maybeError] = await Promise.all([
            // If we catch anything, just return the error instead of throwing, we
            // want to await on closing the connections before re-throwing server
            // close error
            this.serverClose().catch((e) => e),
            this.closeSshClient(),
            this.closeOpenConnections(),
        ]);
        if (maybeError) {
            throw maybeError;
        }
    }
    async closeSshClient() {
        try {
            return events_1.once(this.sshClient, 'close');
        }
        finally {
            this.sshClient.end();
        }
    }
    async closeOpenConnections() {
        const waitForClose = [];
        this.connections.forEach((socket) => {
            waitForClose.push(events_1.once(socket, 'close'));
            socket.destroy();
        });
        await Promise.all(waitForClose);
        this.connections.clear();
    }
}
exports.default = SshTunnel;
